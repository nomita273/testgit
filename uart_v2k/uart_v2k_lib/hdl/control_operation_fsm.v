//
// Module uart_v2k.control_operation.fsm
//
// Created:
//          by - user.group (host.domain)
//          at - 12:00:43 17/05/2007
//
// Generated by Mentor Graphics' HDL Designer(TM) 2007.1
//
`resetall
`timescale 1ns/10ps
module control_operation( 
   // Port Declarations
   input   wire      clk, 
   input   wire      clr_int_en, 
   input   wire      cs, 
   input   wire      nrw, 
   input   wire      rst, 
   input   wire      xmitdt_en, 
   output  reg       clear_flags, 
   output  reg       enable_write, 
   output  reg       start_xmit
);


// Internal Declarations


// Module Declarations

// State encoding
parameter [2:0]
          idle             = 3'd0,
          writing_to_reg   = 3'd1,
          reading_from_reg = 3'd2,
          xmitting         = 3'd3,
          clearing_flags   = 3'd4;

reg [2:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @ *
begin : next_state_block_proc
   // Default Assignment
   clear_flags = 0;
   enable_write = 0;
   start_xmit = 0;

   // Combined Actions
   case (current_state) 
      idle: begin
         if (nrw && ~cs)
            next_state = writing_to_reg;
         else if (~nrw && ~cs)
            next_state = reading_from_reg;
         else
            next_state = idle;
      end
      writing_to_reg: begin
         enable_write = 1;
         if (cs)
            next_state = idle;
         else if (nrw && xmitdt_en)
            next_state = xmitting;
         else
            next_state = writing_to_reg;
      end
      reading_from_reg: begin
         if (cs)
            next_state = idle;
         else if (~nrw && clr_int_en)
            next_state = clearing_flags;
         else
            next_state = reading_from_reg;
      end
      xmitting: begin
         start_xmit = 1;
         if (cs)
            next_state = idle;
         else
            next_state = xmitting;
      end
      clearing_flags: begin
         clear_flags = 1;
         if (cs)
            next_state = idle;
         else
            next_state = clearing_flags;
      end
      default: begin
         next_state = idle;
      end
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk, 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= idle;
   end
   else 
   begin
      current_state <= next_state;
   end
end // Clocked Block

endmodule // control_operation
